import { Prisma } from '@prisma/client';
import prisma from '../config/database';
import {
  BACKUP_VERSION,
  type BackupData,
  type BackupTrip,
  type BackupTransportation,
  type BackupChecklistItem,
} from '../types/backup.types';
import { maskDocumentNumber } from '../types/travelDocument.types';
import { AppError } from '../utils/errors';

type Decimal = Prisma.Decimal;

/**
 * Batch size for loading trips to prevent memory issues.
 * This limits how many trips (with their nested data) are loaded at once.
 */
const TRIP_BATCH_SIZE = 50;

/**
 * Batch size for loading photos within a trip.
 * Photos can be numerous, so we load them in smaller chunks.
 */
const PHOTO_BATCH_SIZE = 200;

/**
 * Transform a raw trip from the database into the backup format.
 * This is extracted to reduce memory by processing trips one at a time.
 */
function transformTripToBackupFormat(trip: Record<string, unknown>): BackupTrip {
  const transportation = trip.transportation as Array<Record<string, unknown>>;
  const journalEntries = trip.journalEntries as Array<Record<string, unknown>>;
  const photoAlbums = trip.photoAlbums as Array<Record<string, unknown>>;
  const tagAssignments = trip.tagAssignments as Array<{ tag: { name: string } }>;
  const companionAssignments = trip.companionAssignments as Array<{ companion: { name: string } }>;
  const checklists = trip.checklists as Array<Record<string, unknown>>;
  const languages = trip.languages as Array<{ languageCode: string; language: string }>;

  return {
    // Trip basic info
    title: trip.title as string,
    description: trip.description as string | null,
    startDate: trip.startDate as string | null,
    endDate: trip.endDate as string | null,
    timezone: trip.timezone as string | null,
    status: trip.status as string,
    privacyLevel: trip.privacyLevel as string,
    coverPhotoId: trip.coverPhotoId as number | null,
    bannerPhotoId: trip.bannerPhotoId as number | null,
    addToPlacesVisited: trip.addToPlacesVisited as boolean | undefined,
    tripType: trip.tripType as string | null,
    tripTypeEmoji: trip.tripTypeEmoji as string | null,
    seriesId: trip.seriesId as number | null,
    seriesOrder: trip.seriesOrder as number | null,

    // Related entities
    locations: trip.locations as BackupTrip['locations'],
    photos: trip.photos as BackupTrip['photos'],
    activities: trip.activities as BackupTrip['activities'],
    transportation: transportation.map((t) => ({
      type: t.type as string,
      startLocationId: t.startLocationId as number | null,
      startLocationText: t.startLocationText as string | null,
      endLocationId: t.endLocationId as number | null,
      endLocationText: t.endLocationText as string | null,
      scheduledStart: t.scheduledStart as string | null,
      scheduledEnd: t.scheduledEnd as string | null,
      startTimezone: t.startTimezone as string | null,
      endTimezone: t.endTimezone as string | null,
      actualStart: t.actualStart as string | null,
      actualEnd: t.actualEnd as string | null,
      company: t.company as string | null,
      referenceNumber: t.referenceNumber as string | null,
      seatNumber: t.seatNumber as string | null,
      bookingReference: t.bookingReference as string | null,
      bookingUrl: t.bookingUrl as string | null,
      cost: t.cost as number | null,
      currency: t.currency as string | null,
      status: t.status as string | undefined,
      delayMinutes: t.delayMinutes as number | null,
      notes: t.notes as string | null,
      connectionGroupId: t.connectionGroupId as string | null,
      isAutoGenerated: t.isAutoGenerated as boolean | undefined,
      calculatedDistance: t.calculatedDistance as number | null,
      calculatedDuration: t.calculatedDuration as number | null,
      distanceSource: t.distanceSource as string | null,
      flightTracking: t.flightTracking as BackupTransportation['flightTracking'],
    })),
    lodging: trip.lodging as BackupTrip['lodging'],
    journalEntries: journalEntries.map((j) => ({
      date: j.date as string | null,
      title: j.title as string | null,
      content: j.content as string,
      entryType: j.entryType as string,
      mood: j.mood as string | null,
      weatherNotes: j.weatherNotes as string | null,
    })),
    // Note: Location, Activity, and Lodging associations are now handled via EntityLinks
    photoAlbums: photoAlbums.map((a) => ({
      name: a.name as string,
      description: a.description as string | null,
      coverPhotoId: a.coverPhotoId as number | null,
      photos: (a.photoAssignments as Array<{ photoId: number; sortOrder?: number }>).map((p) => ({
        photoId: p.photoId,
        sortOrder: p.sortOrder,
      })),
    })),
    weatherData: trip.weatherData as BackupTrip['weatherData'],
    tags: tagAssignments.map((t) => t.tag.name),
    companions: companionAssignments.map((c) => c.companion.name),
    checklists: checklists.map((checklist) => ({
      name: checklist.name as string,
      description: checklist.description as string | null,
      type: checklist.type as string,
      isDefault: checklist.isDefault as boolean | undefined,
      sortOrder: checklist.sortOrder as number | undefined,
      items: checklist.items as BackupChecklistItem[] | undefined,
    })),
    // EntityLinks - stores relationships between entities
    entityLinks: trip.entityLinks as BackupTrip['entityLinks'],
    // Trip languages for language helper feature
    tripLanguages: languages.map((tl) => ({
      languageCode: tl.languageCode,
      language: tl.language,
    })),
  };
}

/**
 * Photo data structure for backup (selected fields only)
 * Note: Prisma returns Decimal for lat/lng which gets serialized to number in JSON
 */
interface BackupPhoto {
  id: number;
  source: string;
  immichAssetId: string | null;
  localPath: string | null;
  thumbnailPath: string | null;
  caption: string | null;
  latitude: Decimal | null;
  longitude: Decimal | null;
  takenAt: Date | null;
}

/**
 * Fetch photos for a trip in batches to prevent memory issues.
 * Uses cursor-based pagination for efficient loading of large photo collections.
 */
async function fetchPhotosInBatches(tripId: number): Promise<BackupPhoto[]> {
  const allPhotos: BackupPhoto[] = [];
  let cursor: number | undefined = undefined;

  while (true) {
    const photos: BackupPhoto[] = await prisma.photo.findMany({
      where: { tripId },
      select: {
        id: true, // Needed for EntityLink lookup and album photo mapping
        source: true,
        immichAssetId: true,
        localPath: true,
        thumbnailPath: true,
        caption: true,
        latitude: true,
        longitude: true,
        takenAt: true,
      },
      take: PHOTO_BATCH_SIZE,
      ...(cursor ? { skip: 1, cursor: { id: cursor } } : {}),
      orderBy: { id: 'asc' },
    });

    if (photos.length === 0) {
      break;
    }

    allPhotos.push(...photos);
    cursor = photos[photos.length - 1].id;

    // If we got fewer than the batch size, we've reached the end
    if (photos.length < PHOTO_BATCH_SIZE) {
      break;
    }
  }

  return allPhotos;
}

/**
 * Fetch a single trip with all its related data, using batched photo loading.
 * This prevents loading too much data at once for trips with many photos.
 */
async function fetchTripWithRelatedData(tripId: number): Promise<Record<string, unknown> | null> {
  // Fetch trip with most related data (except photos which we batch separately)
  const trip = await prisma.trip.findUnique({
    where: { id: tripId },
    include: {
      locations: {
        include: {
          category: {
            select: {
              name: true,
              icon: true,
              color: true,
              isDefault: true,
            },
          },
          children: true,
        },
      },
      activities: {
        select: {
          id: true,
          parentId: true,
          name: true,
          description: true,
          category: true,
          allDay: true,
          startTime: true,
          endTime: true,
          timezone: true,
          cost: true,
          currency: true,
          bookingUrl: true,
          bookingReference: true,
          notes: true,
          manualOrder: true,
        },
      },
      transportation: {
        include: {
          flightTracking: {
            select: {
              flightNumber: true,
              airlineCode: true,
              status: true,
              gate: true,
              terminal: true,
              baggageClaim: true,
            },
          },
        },
      },
      lodging: {
        select: {
          id: true,
          type: true,
          name: true,
          address: true,
          checkInDate: true,
          checkOutDate: true,
          timezone: true,
          confirmationNumber: true,
          bookingUrl: true,
          cost: true,
          currency: true,
          notes: true,
        },
      },
      journalEntries: true,
      photoAlbums: {
        include: {
          photoAssignments: {
            select: {
              photoId: true,
              sortOrder: true,
            },
          },
        },
      },
      weatherData: {
        select: {
          locationId: true,
          date: true,
          temperatureHigh: true,
          temperatureLow: true,
          conditions: true,
          precipitation: true,
          humidity: true,
          windSpeed: true,
        },
      },
      tagAssignments: {
        include: {
          tag: {
            select: {
              name: true,
            },
          },
        },
      },
      companionAssignments: {
        include: {
          companion: {
            select: {
              name: true,
            },
          },
        },
      },
      checklists: {
        include: {
          items: {
            select: {
              name: true,
              description: true,
              isChecked: true,
              isDefault: true,
              sortOrder: true,
              metadata: true,
              checkedAt: true,
            },
          },
        },
      },
      entityLinks: {
        select: {
          sourceType: true,
          sourceId: true,
          targetType: true,
          targetId: true,
          relationship: true,
          sortOrder: true,
          notes: true,
        },
      },
      languages: {
        select: {
          languageCode: true,
          language: true,
        },
      },
    },
  });

  if (!trip) {
    return null;
  }

  // Fetch photos in batches to prevent memory issues for trips with many photos
  const photos = await fetchPhotosInBatches(tripId);

  return {
    ...trip,
    photos,
  };
}

/**
 * Create a complete backup of all user data.
 *
 * CHUNKED APPROACH TO PREVENT OUT-OF-MEMORY ERRORS:
 * -------------------------------------------------
 * Instead of loading all trips with deeply nested data in a single query,
 * this function uses a batched approach:
 *
 * 1. User data, tags, companions, etc. are loaded first (these are typically small)
 * 2. Trip IDs are fetched in batches using cursor-based pagination
 * 3. Each trip's related data is loaded individually
 * 4. Photos (the largest dataset) are loaded in separate batches per trip
 *
 * This ensures memory usage stays bounded regardless of how much data the user has.
 * The tradeoff is more database queries, but this is acceptable for a backup operation.
 */
export async function createBackup(userId: number): Promise<BackupData> {
  try {
    // Fetch user data (small, constant size)
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        username: true,
        email: true,
        timezone: true,
        activityCategories: true,
        tripTypes: true,
        immichApiUrl: true,
        immichApiKey: true,
        weatherApiKey: true,
        aviationstackApiKey: true,
        openrouteserviceApiKey: true,
      },
    });

    if (!user) {
      throw new AppError('User not found', 404);
    }

    // Fetch tags (typically small, bounded by user behavior)
    const tags = await prisma.tripTag.findMany({
      where: { userId },
      select: {
        name: true,
        color: true,
        textColor: true,
      },
    });

    // Fetch companions (typically small, bounded by user behavior)
    const companions = await prisma.travelCompanion.findMany({
      where: { userId },
      select: {
        name: true,
        email: true,
        phone: true,
        notes: true,
        relationship: true,
        isMyself: true,
        avatarUrl: true,
        dietaryPreferences: true,
      },
    });

    // Fetch custom location categories (typically small)
    const locationCategories = await prisma.locationCategory.findMany({
      where: { userId },
      select: {
        name: true,
        icon: true,
        color: true,
        isDefault: true,
      },
    });

    // Fetch global checklists (not trip-specific, typically small)
    const checklists = await prisma.checklist.findMany({
      where: {
        userId,
        tripId: null, // Only global checklists
      },
      include: {
        items: {
          select: {
            name: true,
            description: true,
            isChecked: true,
            isDefault: true,
            sortOrder: true,
            metadata: true,
            checkedAt: true,
          },
        },
      },
    });

    // Fetch travel documents (typically small)
    const travelDocuments = await prisma.travelDocument.findMany({
      where: { userId },
      select: {
        type: true,
        issuingCountry: true,
        documentNumber: true,
        issueDate: true,
        expiryDate: true,
        name: true,
        notes: true,
        isPrimary: true,
        alertDaysBefore: true,
      },
    });

    // Fetch trip series
    const tripSeries = await prisma.tripSeries.findMany({
      where: { userId },
      select: {
        id: true,
        name: true,
        description: true,
      },
    });

    // =========================================================================
    // CHUNKED TRIP LOADING
    // =========================================================================
    // Fetch trips in batches using cursor-based pagination to prevent OOM.
    // We first get just the trip IDs, then load each trip's full data separately.
    // This bounds memory usage to TRIP_BATCH_SIZE trips at a time.
    // =========================================================================

    const allTransformedTrips: BackupTrip[] = [];
    let tripCursor: number | undefined = undefined;

    while (true) {
      // Fetch a batch of trip IDs only (minimal memory footprint)
      const tripBatch: { id: number }[] = await prisma.trip.findMany({
        where: { userId },
        select: { id: true },
        take: TRIP_BATCH_SIZE,
        ...(tripCursor ? { skip: 1, cursor: { id: tripCursor } } : {}),
        orderBy: { id: 'asc' },
      });

      if (tripBatch.length === 0) {
        break;
      }

      // Process each trip in this batch individually
      // This ensures we only hold one trip's full data in memory at a time
      for (const { id: tripId } of tripBatch) {
        const tripWithData = await fetchTripWithRelatedData(tripId);
        if (tripWithData) {
          // Transform and add to results immediately
          // The original trip data can be garbage collected after transformation
          allTransformedTrips.push(transformTripToBackupFormat(tripWithData));
        }
      }

      // Update cursor for next batch
      tripCursor = tripBatch[tripBatch.length - 1].id;

      // If we got fewer than the batch size, we've reached the end
      if (tripBatch.length < TRIP_BATCH_SIZE) {
        break;
      }
    }

    // Build backup data with the pre-transformed trips
    const backupData: BackupData = {
      version: BACKUP_VERSION,
      exportDate: new Date().toISOString(),
      user: user as BackupData['user'],
      tags,
      companions: companions.map((c) => ({
        ...c,
        dietaryPreferences: c.dietaryPreferences as string[],
      })),
      locationCategories,
      checklists: checklists.map((checklist) => ({
        name: checklist.name,
        description: checklist.description,
        type: checklist.type,
        isDefault: checklist.isDefault,
        sortOrder: checklist.sortOrder,
        items: checklist.items,
      })),
      // Trip series
      tripSeries: tripSeries.map((s) => ({
        id: s.id,
        name: s.name,
        description: s.description,
      })),
      // Travel documents with masked document numbers for security
      travelDocuments: travelDocuments.map((doc) => ({
        type: doc.type,
        issuingCountry: doc.issuingCountry,
        // Mask document number: show only last 4 characters
        documentNumber: maskDocumentNumber(doc.documentNumber),
        issueDate: doc.issueDate,
        expiryDate: doc.expiryDate,
        name: doc.name,
        notes: doc.notes,
        isPrimary: doc.isPrimary,
        alertDaysBefore: doc.alertDaysBefore,
      })),
      // Trips are already transformed during chunked loading above
      trips: allTransformedTrips,
    };

    return backupData;
  } catch (error) {
    if (error instanceof AppError) throw error;
    console.error('Error creating backup:', error);
    throw new AppError(
      `Failed to create backup: ${error instanceof Error ? error.message : 'Unknown error'}`,
      500,
      { cause: error }
    );
  }
}

export default {
  createBackup,
};
